# Implementation Plan: Multi-User Todo Application with Authentication

**Branch**: `001-multi-user-todo-auth` | **Date**: 2026-02-05 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/001-multi-user-todo-auth/spec.md`

**Note**: This plan is generated by the `/sp.plan` command focusing on Authentication & Security Layer architecture.

## Summary

Implement a secure, stateless, JWT-based authentication system for a multi-user todo web application. The system enables user signup/signin via Better Auth (Next.js), issues JWT tokens, and enforces strict user isolation across all API endpoints using FastAPI JWT verification middleware. The architecture ensures 100% data isolation with no cross-user access, token-based stateless authentication, and secure frontend-backend integration.

**Primary Requirement**: Enable multiple users to securely authenticate, maintain sessions, and access only their own data through JWT-based authorization enforced at every layer.

**Technical Approach**: Better Auth handles user registration and JWT issuance on the frontend; FastAPI middleware verifies JWT signatures on every protected endpoint; user ID from decoded JWT is matched against resource ownership to ensure strict data isolation.

## Technical Context

**Language/Version**:
- Frontend: TypeScript with Next.js 16+ (App Router)
- Backend: Python 3.11+

**Primary Dependencies**:
- Frontend: Better Auth (JWT plugin), Next.js 16+, React 18+
- Backend: FastAPI, python-jose[cryptography] (JWT), passlib[bcrypt] (password hashing), SQLModel
- Database: Neon Serverless PostgreSQL (via psycopg2 or asyncpg)

**Storage**: Neon Serverless PostgreSQL with two primary tables (users, tasks)

**Testing**: pytest for backend, Jest/React Testing Library for frontend (optional per spec)

**Target Platform**: Web browsers (desktop + mobile), deployed on cloud platform (Vercel for frontend, cloud compute for FastAPI backend)

**Project Type**: Web application (separate frontend and backend)

**Performance Goals**:
- Account creation: <60 seconds (SC-001)
- Signin + view tasks: <5 seconds (SC-002)
- Task operations: <2 seconds (SC-003)
- Support 50 concurrent users without degradation (SC-011)

**Constraints**:
- Stateless authentication (no backend session storage)
- JWT secret shared via `BETTER_AUTH_SECRET` environment variable
- 100% data isolation enforcement (no cross-user access)
- All API endpoints protected by default (JWT required)
- Token expiration enforced (time-limited JWTs)
- Responsive UI (desktop 1920x1080, mobile 375x667)

**Scale/Scope**:
- 50 concurrent users
- 100+ tasks per user without performance degradation
- Authentication state persists across browser sessions

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### âœ… Principle I: Spec-Driven Development (NON-NEGOTIABLE)
- **Status**: PASS
- **Compliance**: Feature specification complete in `spec.md` with 5 prioritized user stories, 30 functional requirements, and 12 measurable success criteria. This plan derives directly from the spec.
- **Validation**: All agents will be invoked with complete context from spec and plan. No manual coding.

### âœ… Principle II: End-to-End Correctness Across All Layers
- **Status**: PASS
- **Compliance**:
  - Data contracts: JWT claims (user_id, email, exp) consistent between Better Auth and FastAPI
  - Auth state sync: Frontend stores JWT, backend verifies independently (stateless)
  - DB models: User and Task entities match API schemas (defined in Phase 1)
  - Error handling: HTTP 401/403/422/500 status codes consistent across layers
  - User isolation: Enforced at auth layer (JWT), API layer (middleware), and DB layer (scoped queries)

### âœ… Principle III: Security-First Architecture (NON-NEGOTIABLE)
- **Status**: PASS
- **Compliance**:
  - JWT-based stateless authentication: Better Auth issues JWT, FastAPI verifies
  - Token verification on every protected endpoint: Middleware checks before handler execution
  - User ID matching: JWT user_id must match resource owner (enforced in routes)
  - No cross-user access: Database queries filtered by authenticated user_id
  - Secrets in environment: `BETTER_AUTH_SECRET` via .env file
  - Token expiry enforced: Time-limited JWTs (e.g., 24h expiration)
  - Auto-rejection: HTTP 401 for invalid/missing tokens, HTTP 403 for unauthorized access

### âœ… Principle IV: Clear Separation of Concerns
- **Status**: PASS
- **Compliance**:
  - **Authentication Layer (Better Auth)**: Signup, signin, JWT issuance (frontend)
  - **Backend Layer (FastAPI)**: JWT verification, business logic, user-scoped DB queries
  - **Frontend Layer (Next.js)**: UI, forms, API client with automatic JWT attachment
  - **Data Layer (Neon PostgreSQL + SQLModel)**: User and task persistence
  - **Contracts**: REST APIs with JSON (OpenAPI spec in Phase 1), Authorization: Bearer <token> headers

### âœ… Principle V: Reproducibility via Explicit Artifacts
- **Status**: PASS
- **Compliance**: This plan generates:
  - `research.md`: Technical decisions and rationale
  - `data-model.md`: User and Task entity definitions
  - `contracts/`: API endpoint specifications (OpenAPI)
  - `quickstart.md`: Setup and testing guide
  - PHR created for this planning session
  - ADRs suggested for significant decisions (user approval required)

### âœ… Principle VI: Agent-Generated Code Only (NON-NEGOTIABLE)
- **Status**: PASS
- **Compliance**:
  - `auth-security-specialist` agent: Better Auth config, JWT verification middleware
  - `fastapi-backend` agent: API endpoints, business logic
  - `nextjs-frontend-builder` agent: Auth UI, API client wrapper
  - `neon-db-manager` agent: Database schema (users, tasks tables)
  - All agents invoked with context from spec + plan

### ğŸ“Š Gate Decision: **PROCEED** to Phase 0 (Research)

All constitutional principles satisfied. No violations requiring justification.

## Project Structure

### Documentation (this feature)

```text
specs/001-multi-user-todo-auth/
â”œâ”€â”€ plan.md              # This file (/sp.plan command output)
â”œâ”€â”€ research.md          # Phase 0 output (technical decisions)
â”œâ”€â”€ data-model.md        # Phase 1 output (User and Task entities)
â”œâ”€â”€ quickstart.md        # Phase 1 output (setup guide)
â”œâ”€â”€ contracts/           # Phase 1 output (API endpoint specs)
â”‚   â”œâ”€â”€ auth.openapi.yaml       # Authentication endpoints
â”‚   â””â”€â”€ tasks.openapi.yaml      # Task management endpoints
â”œâ”€â”€ checklists/          # Validation checklists
â”‚   â””â”€â”€ requirements.md  # Spec quality checklist (already created)
â””â”€â”€ tasks.md             # Phase 2 output (/sp.tasks command - NOT created by /sp.plan)
```

### Source Code (repository root)

```text
# Web application structure (frontend + backend)

backend/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ user.py              # User SQLModel (email, hashed_password, etc.)
â”‚   â”‚   â””â”€â”€ task.py              # Task SQLModel (title, completed, user_id, etc.)
â”‚   â”œâ”€â”€ middleware/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â””â”€â”€ auth.py              # JWT verification middleware
â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ auth.py              # Placeholder (auth handled by frontend Better Auth)
â”‚   â”‚   â””â”€â”€ tasks.py             # Task CRUD endpoints (protected)
â”‚   â”œâ”€â”€ core/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ config.py            # Environment config (BETTER_AUTH_SECRET, DB_URL)
â”‚   â”‚   â””â”€â”€ security.py          # JWT decode/verify utilities
â”‚   â”œâ”€â”€ db/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â””â”€â”€ session.py           # Database connection (Neon PostgreSQL)
â”‚   â””â”€â”€ main.py                  # FastAPI app entry point
â”œâ”€â”€ tests/                       # Optional per spec
â”‚   â”œâ”€â”€ test_auth_middleware.py
â”‚   â””â”€â”€ test_task_endpoints.py
â”œâ”€â”€ .env.example                 # Environment variable template
â”œâ”€â”€ requirements.txt             # Python dependencies
â””â”€â”€ README.md

frontend/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ app/
â”‚   â”‚   â”œâ”€â”€ (auth)/              # Auth route group
â”‚   â”‚   â”‚   â”œâ”€â”€ signin/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ page.tsx     # Signin page
â”‚   â”‚   â”‚   â””â”€â”€ signup/
â”‚   â”‚   â”‚       â””â”€â”€ page.tsx     # Signup page
â”‚   â”‚   â”œâ”€â”€ (protected)/         # Protected route group (requires auth)
â”‚   â”‚   â”‚   â””â”€â”€ tasks/
â”‚   â”‚   â”‚       â””â”€â”€ page.tsx     # Task list page
â”‚   â”‚   â”œâ”€â”€ layout.tsx           # Root layout
â”‚   â”‚   â””â”€â”€ page.tsx             # Landing/redirect page
â”‚   â”œâ”€â”€ lib/
â”‚   â”‚   â”œâ”€â”€ auth.ts              # Better Auth configuration
â”‚   â”‚   â”œâ”€â”€ api-client.ts        # API client with JWT attachment
â”‚   â”‚   â””â”€â”€ types.ts             # TypeScript types (User, Task)
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ SignupForm.tsx       # Signup form component
â”‚   â”‚   â”œâ”€â”€ SigninForm.tsx       # Signin form component
â”‚   â”‚   â”œâ”€â”€ TaskList.tsx         # Task list component
â”‚   â”‚   â”œâ”€â”€ TaskItem.tsx         # Individual task component
â”‚   â”‚   â””â”€â”€ AddTaskForm.tsx      # Add task form component
â”‚   â””â”€â”€ middleware.ts            # Next.js middleware (auth routing)
â”œâ”€â”€ .env.local.example           # Frontend environment variables
â”œâ”€â”€ package.json
â”œâ”€â”€ tsconfig.json
â””â”€â”€ README.md

shared/                          # Optional: Shared types/schemas
â”œâ”€â”€ types/
â”‚   â”œâ”€â”€ user.ts                  # User type definition
â”‚   â””â”€â”€ task.ts                  # Task type definition
â””â”€â”€ README.md

.env.example                     # Root environment template
README.md                        # Project root documentation
```

**Structure Decision**: Web application with separate frontend and backend directories. Frontend uses Next.js App Router with route groups for auth and protected pages. Backend follows FastAPI modular structure with models, middleware, API routes, and core utilities. Shared directory optional for TypeScript types used in both layers.

**Rationale**: Clear physical separation of frontend and backend enables independent deployment (Vercel for Next.js, cloud compute for FastAPI). App Router structure supports authentication-based routing. Middleware directory centralizes JWT verification logic.

## Complexity Tracking

> **No constitutional violations - this section intentionally left empty.**

All architectural decisions align with constitutional principles. JWT-based stateless authentication is mandated by constitution. Separation of frontend/backend is standard for web applications. No additional complexity introduced beyond requirements.

---

## Phase 0: Research & Technical Decisions

### Research Objectives

1. **Better Auth JWT Configuration**: How to configure Better Auth to issue JWT tokens, define claims structure, and set expiration policy
2. **FastAPI JWT Verification**: Best practices for JWT verification middleware using python-jose or similar library
3. **Frontend API Client Pattern**: How to automatically attach JWT to Authorization header for all API requests
4. **Neon PostgreSQL Connection**: Connection string format, connection pooling for serverless, async vs sync driver
5. **Password Hashing**: Secure password hashing with passlib and bcrypt integration with Better Auth
6. **CORS Configuration**: How to configure FastAPI CORS for Next.js frontend origin
7. **Environment Variable Management**: Best practices for sharing BETTER_AUTH_SECRET between frontend and backend
8. **Error Handling Standards**: HTTP status code conventions for auth errors (401, 403, 422)

### Research Output Location

All research findings will be consolidated in:
**`specs/001-multi-user-todo-auth/research.md`**

Format for each research item:
```markdown
### [Topic Name]

**Decision**: [What was chosen]

**Rationale**: [Why this choice was made]

**Alternatives Considered**: [Other options evaluated and why rejected]

**References**: [Links to docs, articles, examples]
```

---

*[Phase 0 research will be completed by exploring each research objective and documenting findings in research.md]*

---

## Phase 1: Design & Contracts

**Prerequisites**: `research.md` complete with all technical decisions documented

### Artifacts to Generate

#### 1. Data Model (`data-model.md`)

Define database entities based on spec Key Entities section:

**User Entity**:
- `id`: UUID or integer primary key
- `email`: String, unique, indexed
- `hashed_password`: String (never store plaintext)
- `created_at`: Timestamp
- Relationships: One-to-many with Task (one user owns many tasks)

**Task Entity**:
- `id`: UUID or integer primary key
- `title`: String, not null
- `completed`: Boolean, default false
- `user_id`: Foreign key to User, not null, indexed
- `created_at`: Timestamp
- `updated_at`: Timestamp
- Relationships: Many-to-one with User (each task belongs to one user)

**Validation Rules** (from spec FR-003, FR-012, FR-018):
- Email: Valid email format
- Password: Minimum 8 characters, at least one uppercase, one lowercase, one number
- Task title: Non-empty string

**State Transitions**:
- Task.completed: false <-> true (toggle)

#### 2. API Contracts (`contracts/`)

Generate OpenAPI specifications for all endpoints based on functional requirements:

**`contracts/auth.openapi.yaml`**:
- `POST /auth/signup`: Create new user account (handled by Better Auth on frontend, documented for reference)
- `POST /auth/signin`: Authenticate user and issue JWT (handled by Better Auth on frontend, documented for reference)
- `POST /auth/signout`: Invalidate session (frontend clears token)

**`contracts/tasks.openapi.yaml`**:
- `GET /api/users/{user_id}/tasks`: List all tasks for authenticated user (protected)
- `POST /api/users/{user_id}/tasks`: Create new task (protected)
- `PATCH /api/users/{user_id}/tasks/{task_id}`: Update task title (protected)
- `PATCH /api/users/{user_id}/tasks/{task_id}/toggle`: Toggle task completion (protected)
- `DELETE /api/users/{user_id}/tasks/{task_id}`: Delete task (protected)

**All protected endpoints require**:
- Header: `Authorization: Bearer <JWT>`
- JWT verification: Signature valid, not expired
- User validation: JWT user_id matches {user_id} in path
- Error responses:
  - 401: Missing or invalid JWT
  - 403: Valid JWT but user_id mismatch
  - 404: Resource not found
  - 422: Validation error

#### 3. Quickstart Guide (`quickstart.md`)

Step-by-step setup and testing guide:

1. **Environment Setup**:
   - Install Node.js 18+ and Python 3.11+
   - Clone repository and navigate to project root

2. **Backend Setup**:
   - `cd backend && python -m venv venv && source venv/bin/activate`
   - `pip install -r requirements.txt`
   - Create `.env` with `BETTER_AUTH_SECRET` and `DATABASE_URL`
   - Run migrations (if using Alembic)
   - Start server: `uvicorn src.main:app --reload`

3. **Frontend Setup**:
   - `cd frontend && npm install`
   - Create `.env.local` with `BETTER_AUTH_SECRET` and `NEXT_PUBLIC_API_URL`
   - Configure Better Auth in `src/lib/auth.ts`
   - Start dev server: `npm run dev`

4. **Testing Authentication Flow**:
   - Navigate to http://localhost:3000/signup
   - Create account with email and password
   - Verify redirect to task list after signup
   - Sign out and sign back in
   - Open browser DevTools Network tab and verify JWT in Authorization header

5. **Testing User Isolation**:
   - Create two user accounts (User A and User B)
   - Create tasks as User A
   - Sign in as User B and verify User A's tasks are not visible
   - Attempt to access User A's task ID as User B (expect 403 error)

6. **Environment Variables**:
   - `BETTER_AUTH_SECRET`: Shared JWT secret (must match frontend and backend)
   - `DATABASE_URL`: Neon PostgreSQL connection string
   - `NEXT_PUBLIC_API_URL`: Backend API base URL (e.g., http://localhost:8000)

#### 4. Agent Context Update

Run agent context update script:
```bash
.specify/scripts/bash/update-agent-context.sh claude
```

This will update `.claude/` context files with technologies from this plan:
- Better Auth (JWT plugin)
- FastAPI with JWT middleware
- SQLModel ORM
- Neon Serverless PostgreSQL
- Next.js App Router

---

*[Phase 1 design artifacts will be generated after research completion]*

---

## Authentication Architecture Details

### JWT Claims Structure

**Issued by Better Auth (Frontend)**:
```json
{
  "sub": "user-id-uuid-or-int",
  "email": "user@example.com",
  "iat": 1234567890,
  "exp": 1234654290
}
```

**Fields**:
- `sub` (subject): User ID (primary key from users table)
- `email`: User email address
- `iat` (issued at): Token creation timestamp
- `exp` (expiration): Token expiry timestamp (e.g., 24 hours from iat)

### Authentication Flow Sequence

```
1. User Signup/Signin
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚   Browser   â”‚
   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
          â”‚ POST /auth/signup or /auth/signin
          â”‚ (email, password)
          â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ Better Auth â”‚  (Next.js frontend)
   â”‚   Plugin    â”‚
   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
          â”‚ 1. Validate credentials (signin) or create user (signup)
          â”‚ 2. Hash password (signup)
          â”‚ 3. Generate JWT with claims (sub, email, exp)
          â”‚ 4. Sign JWT with BETTER_AUTH_SECRET
          â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚   Browser   â”‚
   â”‚  (stores    â”‚
   â”‚   JWT)      â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

2. Authenticated API Request
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚   Browser   â”‚
   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
          â”‚ GET /api/users/{user_id}/tasks
          â”‚ Header: Authorization: Bearer <JWT>
          â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ FastAPI Backend  â”‚
   â”‚  JWT Middleware  â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚ 1. Extract JWT from Authorization header
               â”‚ 2. Verify signature using BETTER_AUTH_SECRET
               â”‚ 3. Check expiration (exp claim)
               â”‚ 4. Decode payload to get user_id (sub claim)
               â”‚ 5. Attach user_id to request context
               â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚  Route Handler   â”‚
   â”‚ /api/users/{...} â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚ 1. Compare JWT user_id with {user_id} in path
               â”‚ 2. If mismatch â†’ 403 Forbidden
               â”‚ 3. If match â†’ proceed with DB query
               â”‚ 4. Filter query: WHERE user_id = JWT.sub
               â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚  Neon PostgreSQL â”‚
   â”‚  (user-scoped    â”‚
   â”‚   query)         â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚ Return only authenticated user's tasks
               â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚     Response     â”‚
   â”‚  (JSON tasks)    â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚ Send to browser
               â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚   Browser   â”‚
   â”‚  (displays  â”‚
   â”‚   tasks)    â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

3. Unauthorized Access Attempt
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚  User A     â”‚
   â”‚  (Browser)  â”‚
   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
          â”‚ GET /api/users/USER_B_ID/tasks
          â”‚ Header: Authorization: Bearer <User A JWT>
          â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ FastAPI Backend  â”‚
   â”‚  JWT Middleware  â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚ 1. Verify JWT â†’ Valid (User A)
               â”‚ 2. Decode â†’ user_id = USER_A_ID
               â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚  Route Handler   â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚ 1. JWT user_id (A) != path user_id (B)
               â”‚ 2. Return 403 Forbidden
               â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚  Response   â”‚
   â”‚  403 Error  â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Security Enforcement Points

1. **Frontend (Next.js + Better Auth)**:
   - Issue JWT only after successful authentication
   - Store JWT securely (httpOnly cookie or secure localStorage)
   - Attach JWT to every API request via `Authorization: Bearer <token>` header
   - Redirect to signin page if JWT missing or expired

2. **Backend (FastAPI Middleware)**:
   - Verify JWT signature on every protected endpoint
   - Check token expiration
   - Extract user ID from JWT claims
   - Reject requests with invalid/missing tokens (401)
   - Make authenticated user ID available to route handlers

3. **Route Handlers**:
   - Compare JWT user_id with resource owner (e.g., user_id in URL path)
   - Reject mismatches with 403 Forbidden
   - Filter all database queries by authenticated user_id
   - Never trust client-provided user IDs

4. **Database Layer**:
   - All task queries include `WHERE user_id = <authenticated_user_id>`
   - Foreign key constraint: tasks.user_id references users.id
   - Indexed user_id for query performance

### Error Handling Standards

| Scenario | HTTP Status | Response Body |
|----------|-------------|---------------|
| Missing JWT | 401 Unauthorized | `{"detail": "Authentication required"}` |
| Invalid JWT signature | 401 Unauthorized | `{"detail": "Invalid authentication credentials"}` |
| Expired JWT | 401 Unauthorized | `{"detail": "Authentication credentials have expired"}` |
| User ID mismatch | 403 Forbidden | `{"detail": "Insufficient permissions"}` |
| Invalid email/password (signin) | 401 Unauthorized | `{"detail": "Invalid email or password"}` |
| Duplicate email (signup) | 422 Unprocessable Entity | `{"detail": "Email already registered"}` |
| Validation error (empty task title) | 422 Unprocessable Entity | `{"detail": "Task title cannot be empty"}` |
| Resource not found | 404 Not Found | `{"detail": "Task not found"}` |
| Database error | 500 Internal Server Error | `{"detail": "An error occurred processing your request"}` |

**Security Note**: Generic error messages prevent user enumeration attacks. Log detailed errors server-side for debugging but return generic messages to client.

---

## Suggested Architecture Decision Records (ADRs)

Based on this plan, the following architectural decisions are significant and should be documented as ADRs (user approval required):

1. **ADR: JWT-Based Stateless Authentication**
   - **Decision**: Use JWT for stateless authentication instead of session-based auth
   - **Significance**: Affects scalability, deployment architecture, and security model
   - **Alternatives**: Session-based auth with database, OAuth delegation, API keys

2. **ADR: Better Auth for Frontend Authentication**
   - **Decision**: Use Better Auth library for Next.js authentication instead of building custom auth
   - **Significance**: Affects frontend architecture, JWT issuance, and auth UX
   - **Alternatives**: NextAuth.js, custom JWT implementation, Auth0 integration

3. **ADR: User ID Matching for Authorization**
   - **Decision**: Require JWT user_id to match resource owner user_id in URL path
   - **Significance**: Core security pattern for preventing unauthorized access
   - **Alternatives**: Session-based ownership, role-based access control, API-level filtering only

4. **ADR: Shared JWT Secret via Environment Variable**
   - **Decision**: Share `BETTER_AUTH_SECRET` between frontend and backend via environment variable
   - **Significance**: Enables independent JWT verification without inter-service calls
   - **Alternatives**: Public/private key pairs (RS256), backend auth validation endpoint, shared auth service

**Recommendation**: After reviewing these decisions, run `/sp.adr <decision-title>` for each ADR you wish to document.

Example:
```
ğŸ“‹ Architectural decision detected: JWT-Based Stateless Authentication
   Document reasoning and tradeoffs? Run `/sp.adr jwt-stateless-authentication`
```

---

## Post-Phase-1 Constitution Check

*[To be completed after Phase 1 design artifacts are generated]*

**Validation items**:
- âœ… Data models match API contracts (User and Task entities consistent)
- âœ… API contracts include authentication headers (Authorization: Bearer <JWT>)
- âœ… Quickstart guide includes steps to verify user isolation
- âœ… No implementation details leaked into spec (spec remains technology-agnostic)
- âœ… All security invariants addressed in design (JWT verification, user_id matching, no cross-user access)

---

## Next Steps

After completing this plan:

1. **Generate Phase 0 Research** (`research.md`):
   - Execute research tasks for each technical unknown
   - Document decisions, rationale, and alternatives
   - Resolve any remaining "NEEDS CLARIFICATION" items

2. **Generate Phase 1 Design Artifacts**:
   - `data-model.md`: User and Task entity definitions with validation rules
   - `contracts/auth.openapi.yaml`: Authentication endpoint specifications
   - `contracts/tasks.openapi.yaml`: Task management endpoint specifications
   - `quickstart.md`: Setup and testing guide

3. **Update Agent Context**:
   - Run `.specify/scripts/bash/update-agent-context.sh claude`
   - Verify technologies added to context files

4. **Proceed to Task Generation**:
   - Run `/sp.tasks` to generate actionable, dependency-ordered task list
   - Tasks will be organized by user story (P1: Auth, P2: Task CRUD, etc.)
   - Each task will include exact file paths and acceptance criteria

5. **Consider ADRs** (Optional but Recommended):
   - Review suggested ADRs above
   - Run `/sp.adr <decision-title>` for significant architectural decisions
   - Document rationale and alternatives for future reference

---

**Plan Status**: âœ… Complete - Ready for Phase 0 (Research)
**Branch**: `001-multi-user-todo-auth`
**Spec**: [spec.md](./spec.md)
**Next Command**: Proceed with research or run `/sp.tasks` after Phase 1 completion
